<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>부인과 종양 랜덤 퀴즈</title>
  <link rel="manifest" href="manifest.json?v=5">
  <meta name="theme-color" content="#4CAF50">
  <style>
    body { font-family: Arial, sans-serif; max-width:800px; margin:20px auto; padding:16px; text-align:center; }
    header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    h1 { margin:0; font-size:1.25rem; }
    #status { color:#666; font-size:0.95rem; margin-top:8px; text-align:left; }
    .question { margin:20px 0; font-size:1.15rem; white-space:pre-line; text-align:left; }
    .answer { margin-top:10px; font-weight:600; color:#0a6; white-space:pre-line; display:none; text-align:left; }
    .controls { margin-top:18px; }
    button { padding:10px 14px; margin:6px; font-size:1rem; }
    .progress-wrap { margin-top:14px; text-align:left; }
    .progress-info { font-size:0.92rem; color:#444; margin-bottom:6px; }
    .progress-bar { width:100%; height:12px; background:#eee; border-radius:8px; overflow:hidden; }
    .progress-inner { height:100%; width:0%; background:#4caf50; transition: width 0.25s ease; }
    small.note { display:block; color:#888; margin-top:8px; text-align:left; }
  </style>
</head>
<body>
  <header>
    <h1>부인과 종양 랜덤 퀴즈</h1>
    <div>
      <button id="btnToggleMode">복습 모드로</button>
      <button id="btnReset">초기화</button>
    </div>
  </header>

  <div id="status" aria-live="polite">로딩 중...</div>

  <div class="question" id="question">문제가 여기에 표시됩니다.</div>
  <div class="answer" id="answer"></div>

  <div class="controls" id="controls">
    <button id="btnShowAnswer">정답 보기</button>
    <button id="btnMarkWrong">오답 저장</button>
    <button id="btnPrev">이전 문제</button>
    <button id="btnNext">다음 문제</button>
    <!-- 복습 모드에서 첫 문제로 돌아가기 버튼 -->
    <button id="btnRestartReview" style="display:none;">복습 첫 문제로</button>
    <!-- 복습 모드에서 오답 제거 버튼 -->
    <button id="btnRemoveWrong" style="display:none;">오답 제거</button>
  </div>

  <div class="progress-wrap">
    <div class="progress-info" id="progressInfo">진행: 0 / 0 (남음: 0)</div>
    <div class="progress-bar"><div id="progressInner" class="progress-inner"></div></div>
    <small class="note">※ 정답 보기 버튼은 정답만 보여줍니다. 다음 문제로 이동하려면 '다음 문제' 버튼을 누르세요.</small>
  </div>

<script>
  // 기존 문제 데이터
  const questions = [
    { q: "자궁경부암 stage I의 병기 설정 기준은?", a: "종양이 자궁경부에만 국한됨(자궁체부 침범은 무시함)" },
    { q: "자궁경부암 stage II의 병기 설정 기준은?", a: "종양이 질 상부 or parametrium 침범" },
    { q: "자궁경부암 stage III의 병기 설정 기준은?", a: "종양이 질 하부 or pelvic wall 침범, hydronephrosis/신기능 소실, 림프절 침범" },
    { q: "자궁경부암 stage IV의 병기 설정 기준은?", a: "종양이 인접 기관 침범 or 원격 전이" },
    { q: "자궁경부암 stage IA의 병기 설정 기준은?", a: "종양의 자궁경부 기질(stroma) 침범 깊이가 5mm 이하, 현미경적으로만 관찰 가능" },
    { q: "자궁경부암 stage IB의 병기 설정 기준은?", a: "종양의 침범 깊이가 5mm 초과" },
    { q: "자궁경부암 stage IIA의 병기 설정 기준은?", a: "종양이 질 상부 2/3 침범" },
    { q: "자궁경부암 stage IB의 병기 설정 기준과 치료는?", a: "기준: 종양이 parametrium 침범<br>치료: CCRT" },
    { q: "자궁경부암 stage IIIA의 병기 설정 기준과 치료는?", a: "기준: 종양이 질 하부 1/3 침범<br>치료: CCRT" },
    { q: "자궁경부암 stage IIIB의 병기 설정 기준과 치료는?", a: "기준: 종양이 pelvic wall 침범/hydronephrosis/신기능 소실<br>치료: CCRT" },
    { q: "자궁경부암 stage IIIC의 병기 설정 기준은??", a: "종양이 림프절 침범" },
    { q: "자궁경부암 stage IVA의 병기 설정 기준과 치료는?", a: "기준: 종양이 방광/직장 등 인접 기관 침범<br>치료: CCRT" },
    { q: "자궁경부암 stage IVB의 병기 설정 기준과 치료는?", a: "기준: 종양의 원격 전이<br>치료: systemic CTx, palliative Tx" },
    { q: "자궁경부암 stage IA1의 병기 설정 기준과 치료는?", a: "기준: 침범 깊이 3mm 이하(이 병기를 미세침윤암(microinvasive cancer)이라고도 부름<br>치료: LVSI(-): 원뿔절제술 or 단순자궁절제술 / LVSI(+): 변형근치자궁절제술 + 골반LN절제술" },
    { q: "자궁경부암 stage IA2의 병기 설정 기준과 치료는?", a: "기준: 침범 깊이 3~5mm<br>치료: (변형근치자궁절제술 or 근치자궁경부절제술) + 골반LN절제술 / LVSI(-)이라면 원뿔절제술도 고려" },
    { q: "자궁경부암 stage IB1의 병기 설정 기준과 치료는?", a: "기준: 종괴 지름 2cm 이하<br>치료: (변형근치자궁절제술 or 근치자궁경부절제술) + 골반LN절제술 / LVSI(-)이라면 원뿔절제술도 고려" },
    { q: "자궁경부암 stage IB2의 병기 설정 기준과 치료는?", a: "기준: 종괴 지름 2~4cm<br>치료: 변형근치자궁절제술 + 골반LN절제술" },
    { q: "자궁경부암 stage IB3의 병기 설정 기준과 치료는?", a: "기준: 종괴 지름 4cm 초과<br>치료: CCRT" },
    { q: "자궁경부암 stage IIA1의 병기 설정 기준과 치료는?", a: "기준: 종괴 지름 4cm 이하<br>치료: 변형근치자궁절제술 + 골반LN절제술" },
    { q: "자궁경부암 stage IIA2의 병기 설정 기준과 치료는?", a: "기준: 종괴 지름 4cm 초과<br>치료: CCRT" },
    { q: "자궁경부암 stage IIIC1의 병기 설정 기준과 치료는?", a: "기준: pelvic LN 침범<br>치료: CCRT" },
    { q: "자궁경부암 stage IIIC2의 병기 설정 기준과 치료는?", a: "기준: para-aortic LN 침범<br>치료: CCRT" }
  ];

  const KEY = {
    WRONG: 'quiz_wrong_v1',
    MODE: 'quiz_mode_v1',
    NORMAL_ORDER: 'quiz_normal_order_v1',
    NORMAL_IDX: 'quiz_normal_idx_v1',
    REVIEW_ORDER: 'quiz_review_order_v1',
    REVIEW_IDX: 'quiz_review_idx_v1'
  };

  let wrongList   = JSON.parse(localStorage.getItem(KEY.WRONG) || '[]');
  let mode        = localStorage.getItem(KEY.MODE) || 'normal';
  let orderNormal = JSON.parse(localStorage.getItem(KEY.NORMAL_ORDER) || 'null');
  let idxNormal   = parseInt(localStorage.getItem(KEY.NORMAL_IDX) || '0', 10);
  let orderReview = JSON.parse(localStorage.getItem(KEY.REVIEW_ORDER) || 'null');
  let idxReview   = parseInt(localStorage.getItem(KEY.REVIEW_IDX) || '0', 10);

  const elStatus          = document.getElementById('status');
  const elQuestion        = document.getElementById('question');
  const elAnswer          = document.getElementById('answer');
  const elBtnShow         = document.getElementById('btnShowAnswer');
  const elBtnWrong        = document.getElementById('btnMarkWrong');
  const elBtnNext         = document.getElementById('btnNext');
  const elBtnPrev         = document.getElementById('btnPrev');
  const elBtnToggle       = document.getElementById('btnToggleMode');
  const elBtnReset        = document.getElementById('btnReset');
  const elProgressInfo    = document.getElementById('progressInfo');
  const elProgressInner   = document.getElementById('progressInner');
  const elBtnRestartReview= document.getElementById('btnRestartReview');
  const elBtnRemoveWrong  = document.getElementById('btnRemoveWrong');

  function shuffledArray(n){
    const arr = Array.from({length:n}, (_,i)=>i);
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function saveAll(){
    localStorage.setItem(KEY.WRONG, JSON.stringify(wrongList));
    localStorage.setItem(KEY.MODE, mode);
    if(orderNormal) localStorage.setItem(KEY.NORMAL_ORDER, JSON.stringify(orderNormal));
    localStorage.setItem(KEY.NORMAL_IDX, String(idxNormal));
    if(orderReview) localStorage.setItem(KEY.REVIEW_ORDER, JSON.stringify(orderReview));
    localStorage.setItem(KEY.REVIEW_IDX, String(idxReview));
  }

  function clearAll(){
    localStorage.removeItem(KEY.WRONG);
    localStorage.removeItem(KEY.MODE);
    localStorage.removeItem(KEY.NORMAL_ORDER);
    localStorage.removeItem(KEY.NORMAL_IDX);
    localStorage.removeItem(KEY.REVIEW_ORDER);
    localStorage.removeItem(KEY.REVIEW_IDX);
    wrongList = [];
    mode = 'normal';
    orderNormal=null; orderReview=null;
    idxNormal=0; idxReview=0;
  }

  function ensureOrders(skipShuffle=false){
    // ✅ 일반 모드 순서 보장 (기본: 처음 한 번 섞고 고정)
    if(!Array.isArray(orderNormal) || orderNormal.length !== questions.length){
      orderNormal = Array.from({length: questions.length}, (_,i)=>i);
      if(!skipShuffle){
        orderNormal.sort(()=>Math.random()-0.5);
      }
    }

    // ✅ 복습 모드 순서 보장
    if(!Array.isArray(orderReview) || orderReview.length !== wrongList.length){
      orderReview = Array.from({length: wrongList.length}, (_,i)=>i);
    }

    // ✅ 인덱스 보정
    idxNormal = Math.min(Math.max(0, idxNormal), Math.max(0, orderNormal.length-1));
    idxReview = Math.min(Math.max(0, idxReview), Math.max(0, wrongList.length-1));
  }

  function currentListAndIndex(){
    if(mode==='normal'){
      return {listType:'normal', order:orderNormal, idx:idxNormal, total:orderNormal.length};
    } else {
      return {listType:'review', order:orderReview, idx:idxReview, total:orderReview.length};
    }
  }

  function getCurrentQuestion(){
    const info = currentListAndIndex();
    if(info.total===0) return null;
    if(info.listType==='normal'){
      return questions[info.order[info.idx]];
    } else {
      return wrongList[info.order[info.idx]];
    }
  }

  function updateProgressBar(idx,total,percent){
    elProgressInfo.innerText=`진행: ${idx}/${total}  (${percent}%)`;
    elProgressInner.style.width=total===0?'0%':`${percent}%`;
  }

  function updateToggleText(){
    elBtnToggle.textContent = mode==='normal'?`복습 모드 (${wrongList.length})`:'일반 모드로';
  }

  function render(skipShuffle=false){
    ensureOrders(skipShuffle);
    saveAll();
    const info=currentListAndIndex();

    // 버튼 표시
    if(mode==='review' && info.total>0){
      elBtnRestartReview.style.display='inline-block';
      elBtnRemoveWrong.style.display='inline-block';
    } else {
      elBtnRestartReview.style.display='none';
      elBtnRemoveWrong.style.display='none';
    }

    if(info.total===0){
      elStatus.innerText = mode==='normal'? '문제가 비어있습니다. questions 배열을 채워주세요.' : '복습할 문제가 없습니다.';
      elQuestion.innerText = mode==='normal'? '문제가 없습니다.' : '복습할 문제가 없습니다.';
      elAnswer.style.display='none';
      updateProgressBar(0,info.total,0);
      updateToggleText();
      return;
    }

    // 완료 상태
    if(info.idx >= info.total){
      elQuestion.innerText='모든 문제가 완료되었습니다.';
      elAnswer.style.display='none';
      updateProgressBar(info.total, info.total, 100);
      updateToggleText();
      return;
    }

    const cur = getCurrentQuestion();
    if(!cur){
      elQuestion.innerText='문제가 없습니다.';
      elAnswer.style.display='none';
      updateProgressBar(info.idx,info.total,Math.round((info.idx/Math.max(1,info.total))*100));
      updateToggleText();
      return;
    }

    elQuestion.innerHTML = cur.q;
    elAnswer.innerHTML = cur.a;
    elAnswer.style.display='none';

    const currentNumber=info.idx+1;
    const remaining=Math.max(0,info.total-info.idx-1);
    elStatus.innerText=`모드: ${mode==='normal'?'일반':'복습'}  •  ${currentNumber} / ${info.total}  (남음: ${remaining})`;
    updateProgressBar(info.idx, info.total, Math.round((info.idx/Math.max(1,info.total))*100));
    updateToggleText();
  }

  function showAnswer(){
    const cur = getCurrentQuestion();
    if(!cur) return;
    elAnswer.style.display='block';
  }

  function markWrong(){
    const info=currentListAndIndex();
    if(info.total===0 || info.idx>=info.total) return;
    const cur=getCurrentQuestion();
    if(!cur) return;
    if(!wrongList.some(it=>it.q===cur.q && it.a===cur.a)){
      wrongList.push({q:cur.q,a:cur.a});
      orderReview = Array.from({length: wrongList.length}, (_,i)=>i); // 새로 고정
      idxReview=Math.min(idxReview, orderReview.length-1);
      saveAll();
      updateToggleText();
    }
  }

  function removeWrong(){
    const cur = getCurrentQuestion();
    if(!cur) return;
    if(removeFromWrongListByQA(cur.q, cur.a)){
      render();
    }
  }

  function nextQuestion(){
    const info=currentListAndIndex();
    if(info.total===0){ render(); return; }
    if(info.listType==='normal'){
      idxNormal++;
      if(idxNormal>info.total) idxNormal=info.total;
    } else {
      idxReview++;
      if(idxReview>info.total) idxReview=info.total;
    }
    saveAll();
    render();
  }

  function prevQuestion(){
    const info=currentListAndIndex();
    if(info.total===0){ render(); return; }
    if(info.listType==='normal'){
      if(idxNormal<=0) return;
      idxNormal = Math.max(0, idxNormal-1);
      const prev = questions[orderNormal[idxNormal]];
      if(prev) removeFromWrongListByQA(prev.q,prev.a);
    } else {
      if(idxReview<=0) return;
      idxReview=Math.max(0, idxReview-1);
    }
    saveAll();
    render();
  }

  function removeFromWrongListByQA(q,a){
    const i = wrongList.findIndex(it => it.q === q && it.a === a);
    if(i!==-1){
      wrongList.splice(i,1);
      // 순서 재구성 및 인덱스 보정
      orderReview = Array.from({length: wrongList.length}, (_,k)=>k);
      if(idxReview >= wrongList.length){
        idxReview = Math.max(0, wrongList.length - 1);
      }
      saveAll();
      updateToggleText();
      return true;
    }
    return false;
  }

  function restartReview(){
    idxReview=0;
    saveAll();
    render();
  }

  function toggleMode(){
    mode = (mode==='normal')?'review':'normal';
    localStorage.setItem(KEY.MODE, mode);
    if(mode==='review' && wrongList.length===0){
      alert('복습할 오답이 없습니다.');
      mode='normal';
      localStorage.setItem(KEY.MODE, mode);
      return;
    }
    ensureOrders();
    render();
  }

  function resetProgress(){
    if(!confirm('진행 상황(섞인 순서 및 인덱스)과 오답 목록을 초기화할까요?')) return;
    clearAll();
    ensureOrders();
    saveAll();
    render();
  }

  elBtnShow.addEventListener('click', showAnswer);
  elBtnWrong.addEventListener('click', markWrong);
  elBtnNext.addEventListener('click', nextQuestion);
  elBtnPrev.addEventListener('click', prevQuestion);
  elBtnToggle.addEventListener('click', toggleMode);
  elBtnReset.addEventListener('click', resetProgress);
  elBtnRestartReview.addEventListener('click', restartReview);
  elBtnRemoveWrong.addEventListener('click', removeWrong);

  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{
      navigator.serviceWorker.register('sw.js?v=5').catch(e=>{
        console.warn('ServiceWorker 등록 실패:', e);
      });
    });
  }

  ensureOrders();
  render();
</script>
</body>
</html>
